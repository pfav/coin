%% Generated by the Erlang ASN.1 PER (unaligned) compiler. Version: 5.0.16
%% Purpose: Encoding and decoding of the types in CoinProto.

-module('CoinProto').
-compile(nowarn_unused_vars).
-dialyzer(no_improper_lists).
-dialyzer(no_match).
-include("CoinProto.hrl").
-asn1_info([{vsn,'5.0.16'},
            {module,'CoinProto'},
            {options,[warnings,uper,errors,
 {cwd,"/home/pfav/Desktop/coin/proto"},
 {outdir,"/home/pfav/Desktop/coin/proto"},
 noobj,jer,
 {i,"."},
 {i,"/home/pfav/Desktop/coin/proto"}]}]).

-ifdef(jsone).
-define(JSON_DECODE(Data),jsone:decode(Data)).
-define(JSON_ENCODE(Term),jsone:encode(Term)).
-else.
-define(JSON_DECODE(Data),jsx:decode(Data,[return_maps])).
-define(JSON_ENCODE(Term),jsx:encode(Term)).
-endif.
-export([encoding_rule/0,maps/0,bit_string_format/0,
         legacy_erlang_types/0]).
-export(['dialyzer-suppressions'/1]).
-export([
enc_Hash/1,
enc_PublicKey/1,
enc_BranchSet/1,
enc_Branch/1,
enc_Block/1,
enc_Transaction/1,
enc_TransactionIn/1,
enc_TransactionOut/1
]).

-export([
dec_Hash/1,
dec_PublicKey/1,
dec_BranchSet/1,
dec_Branch/1,
dec_Block/1,
dec_Transaction/1,
dec_TransactionIn/1,
dec_TransactionOut/1
]).

-export([
typeinfo_Hash/0,
typeinfo_PublicKey/0,
typeinfo_BranchSet/0,
typeinfo_Branch/0,
typeinfo_Block/0,
typeinfo_Transaction/0,
typeinfo_TransactionIn/0,
typeinfo_TransactionOut/0
]).

-export([info/0]).

-export([encode/2,decode/2]).
-export([jer_encode/2,jer_decode/2]).

encoding_rule() -> uper.

maps() -> false.

bit_string_format() -> bitstring.

legacy_erlang_types() -> false.

encode(Type, Data) ->
try complete(encode_disp(Type, Data)) of
  Bytes ->
    {ok,Bytes}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.

jer_encode(Type, Data) ->
try ?JSON_ENCODE(encode_jer('CoinProto', list_to_existing_atom(lists:concat([typeinfo_,Type])), Data)) of
  Bytes ->
    {ok,Bytes}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.

decode(Type, Data) ->
try
   {Result,_Rest} = decode_disp(Type, Data),
   {ok,Result}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.

jer_decode(Type, Data) ->
try
   Result = decode_jer('CoinProto', list_to_existing_atom(lists:concat([typeinfo_,Type])), ?JSON_DECODE(Data)),
   {ok,Result}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.

encode_disp('Hash', Data) -> enc_Hash(Data);
encode_disp('PublicKey', Data) -> enc_PublicKey(Data);
encode_disp('BranchSet', Data) -> enc_BranchSet(Data);
encode_disp('Branch', Data) -> enc_Branch(Data);
encode_disp('Block', Data) -> enc_Block(Data);
encode_disp('Transaction', Data) -> enc_Transaction(Data);
encode_disp('TransactionIn', Data) -> enc_TransactionIn(Data);
encode_disp('TransactionOut', Data) -> enc_TransactionOut(Data);
encode_disp(Type, _Data) -> exit({error,{asn1,{undefined_type,Type}}}).

decode_disp('Hash', Data) -> dec_Hash(Data);
decode_disp('PublicKey', Data) -> dec_PublicKey(Data);
decode_disp('BranchSet', Data) -> dec_BranchSet(Data);
decode_disp('Branch', Data) -> dec_Branch(Data);
decode_disp('Block', Data) -> dec_Block(Data);
decode_disp('Transaction', Data) -> dec_Transaction(Data);
decode_disp('TransactionIn', Data) -> dec_TransactionIn(Data);
decode_disp('TransactionOut', Data) -> dec_TransactionOut(Data);
decode_disp(Type, _Data) -> exit({error,{asn1,{undefined_type,Type}}}).

info() ->
   case ?MODULE:module_info(attributes) of
     Attributes when is_list(Attributes) ->
       case lists:keyfind(asn1_info, 1, Attributes) of
         {_,Info} when is_list(Info) ->
           Info;
         _ ->
           []
       end;
     _ ->
       []
   end.
enc_Hash(Val) ->
Enc1@len = byte_size(Val),
if Enc1@len =:= 64 ->
Val
end.


dec_Hash(Bytes) ->
begin
<<V1@V0:64/binary-unit:8,V1@Buf1/bitstring>> = Bytes,
V1@Conv2 = binary:copy(V1@V0),
{V1@Conv2,V1@Buf1}
end.

enc_PublicKey(Val) ->
Enc1@len = byte_size(Val),
if Enc1@len =:= 32 ->
Val
end.


dec_PublicKey(Bytes) ->
begin
<<V1@V0:32/binary-unit:8,V1@Buf1/bitstring>> = Bytes,
V1@Conv2 = binary:copy(V1@V0),
{V1@Conv2,V1@Buf1}
end.

enc_BranchSet(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 8 =:= 0 ->
[Enc1@len@sub|[enc_BranchSet_SEQOF(Comp) || Comp <- Val]]
end.

enc_BranchSet_SEQOF(Val) ->
[begin
%% attribute slot(1) with type INTEGER
Enc2@element = element(2, Val),
[<<0:1>>|encode_unconstrained_number(Enc2@element)]
end|begin
%% attribute branch(2) with type Branch
Enc4@element = element(3, Val),
enc_Branch(Enc4@element)
end].


dec_BranchSet(Bytes) ->
%% Length with constraint {1,256}
<<V1@V0:8,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components1(V1@Add2, V1@Buf1, []).


dec_BranchSet_SEQOF(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute slot(1) with type INTEGER
{Term1,Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@Buf4/bitstring>> when V2@V3 =/= 0 ->
{V2@V3,V2@Buf4};
<<1:1,0:1,V2@V4:14,V2@Buf5/bitstring>> when V2@V4 =/= 0 ->
{V2@V4,V2@Buf5}
end,
<<V2@V6:V2@V0/signed-unit:8,V2@Buf7/bitstring>> = V2@Buf1,
{V2@V6,V2@Buf7}
end,

%% attribute branch(2) with type Branch
{Term2,Bytes3} = dec_Branch(Bytes2),

%% Extensions
{Extensions,Bytes4} = case Ext of
0 -> {<<>>,Bytes3};
1 ->
{V3@V0,V3@Buf1} = case Bytes3 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V9:V3@V0/bitstring-unit:1,V3@Buf10/bitstring>> = V3@Buf1,
{V3@V9,V3@Buf10}
end,
Bytes5= skipextensions(Bytes4, 1, Extensions),
Res1 = {'BranchSet_SEQOF',Term1,Term2},
{Res1,Bytes5}.

enc_Branch(Val) ->
[begin
%% attribute latest-hash(1) with type OCTET STRING
Enc2@element = element(2, Val),
Enc3@len = byte_size(Enc2@element),
if Enc3@len =:= 64 ->
[<<0:1>>|Enc2@element]
end
end,
begin
%% attribute current-difficulty(2) with type INTEGER
Enc4@element = element(3, Val),
encode_unconstrained_number(Enc4@element)
end,
begin
%% attribute cumulative-difficulty(3) with type INTEGER
Enc6@element = element(4, Val),
encode_unconstrained_number(Enc6@element)
end,
begin
%% attribute length(4) with type INTEGER
Enc8@element = element(5, Val),
encode_unconstrained_number(Enc8@element)
end,
begin
%% attribute coinbase(5) with type INTEGER
Enc10@element = element(6, Val),
encode_unconstrained_number(Enc10@element)
end|begin
%% attribute supply(6) with type INTEGER
Enc12@element = element(7, Val),
encode_unconstrained_number(Enc12@element)
end].


dec_Branch(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute latest-hash(1) with type OCTET STRING
{Term1,Bytes2} = begin
<<V2@V0:64/binary-unit:8,V2@Buf1/bitstring>> = Bytes1,
V2@Conv2 = binary:copy(V2@V0),
{V2@Conv2,V2@Buf1}
end,

%% attribute current-difficulty(2) with type INTEGER
{Term2,Bytes3} = begin
{V3@V0,V3@Buf1} = case Bytes2 of
<<0:1,V3@V3:7,V3@Buf4/bitstring>> when V3@V3 =/= 0 ->
{V3@V3,V3@Buf4};
<<1:1,0:1,V3@V4:14,V3@Buf5/bitstring>> when V3@V4 =/= 0 ->
{V3@V4,V3@Buf5}
end,
<<V3@V6:V3@V0/signed-unit:8,V3@Buf7/bitstring>> = V3@Buf1,
{V3@V6,V3@Buf7}
end,

%% attribute cumulative-difficulty(3) with type INTEGER
{Term3,Bytes4} = begin
{V4@V0,V4@Buf1} = case Bytes3 of
<<0:1,V4@V3:7,V4@Buf4/bitstring>> when V4@V3 =/= 0 ->
{V4@V3,V4@Buf4};
<<1:1,0:1,V4@V4:14,V4@Buf5/bitstring>> when V4@V4 =/= 0 ->
{V4@V4,V4@Buf5}
end,
<<V4@V6:V4@V0/signed-unit:8,V4@Buf7/bitstring>> = V4@Buf1,
{V4@V6,V4@Buf7}
end,

%% attribute length(4) with type INTEGER
{Term4,Bytes5} = begin
{V5@V0,V5@Buf1} = case Bytes4 of
<<0:1,V5@V3:7,V5@Buf4/bitstring>> when V5@V3 =/= 0 ->
{V5@V3,V5@Buf4};
<<1:1,0:1,V5@V4:14,V5@Buf5/bitstring>> when V5@V4 =/= 0 ->
{V5@V4,V5@Buf5}
end,
<<V5@V6:V5@V0/signed-unit:8,V5@Buf7/bitstring>> = V5@Buf1,
{V5@V6,V5@Buf7}
end,

%% attribute coinbase(5) with type INTEGER
{Term5,Bytes6} = begin
{V6@V0,V6@Buf1} = case Bytes5 of
<<0:1,V6@V3:7,V6@Buf4/bitstring>> when V6@V3 =/= 0 ->
{V6@V3,V6@Buf4};
<<1:1,0:1,V6@V4:14,V6@Buf5/bitstring>> when V6@V4 =/= 0 ->
{V6@V4,V6@Buf5}
end,
<<V6@V6:V6@V0/signed-unit:8,V6@Buf7/bitstring>> = V6@Buf1,
{V6@V6,V6@Buf7}
end,

%% attribute supply(6) with type INTEGER
{Term6,Bytes7} = begin
{V7@V0,V7@Buf1} = case Bytes6 of
<<0:1,V7@V3:7,V7@Buf4/bitstring>> when V7@V3 =/= 0 ->
{V7@V3,V7@Buf4};
<<1:1,0:1,V7@V4:14,V7@Buf5/bitstring>> when V7@V4 =/= 0 ->
{V7@V4,V7@Buf5}
end,
<<V7@V6:V7@V0/signed-unit:8,V7@Buf7/bitstring>> = V7@Buf1,
{V7@V6,V7@Buf7}
end,

%% Extensions
{Extensions,Bytes8} = case Ext of
0 -> {<<>>,Bytes7};
1 ->
{V8@V0,V8@Buf1} = case Bytes7 of
<<0:1,V8@V3:6,V8@Buf4/bitstring>> ->
V8@Add5 = V8@V3 + 1,
{V8@Add5,V8@Buf4};
<<1:1,V8@Buf2/bitstring>> ->
{V8@V3,V8@Buf4} = case V8@Buf2 of
<<0:1,V8@V6:7,V8@Buf7/bitstring>> when V8@V6 =/= 0 ->
{V8@V6,V8@Buf7};
<<1:1,0:1,V8@V7:14,V8@Buf8/bitstring>> when V8@V7 =/= 0 ->
{V8@V7,V8@Buf8}
end,
{V8@V3,V8@Buf4}
end,
<<V8@V9:V8@V0/bitstring-unit:1,V8@Buf10/bitstring>> = V8@Buf1,
{V8@V9,V8@Buf10}
end,
Bytes9= skipextensions(Bytes8, 1, Extensions),
Res1 = {'Branch',Term1,Term2,Term3,Term4,Term5,Term6},
{Res1,Bytes9}.

enc_Block(Val) ->
[begin
Enc1@element = element(4, Val),
Enc2@element = element(7, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
%% attribute version(1) with type INTEGER
Enc4@element = element(2, Val),
encode_unconstrained_number(Enc4@element)
end,
begin
%% attribute index(2) with type INTEGER
Enc6@element = element(3, Val),
encode_unconstrained_number(Enc6@element)
end,
begin
%% attribute hash(3) with type OCTET STRING
Enc8@element = element(4, Val),
if Enc8@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc9@len = byte_size(Enc8@element),
if Enc9@len =:= 64 ->
Enc8@element
end
end
end
end,
begin
%% attribute prev-hash(4) with type OCTET STRING
Enc11@element = element(5, Val),
Enc12@len = byte_size(Enc11@element),
if Enc12@len =:= 64 ->
Enc11@element
end
end,
begin
%% attribute timestamp(5) with type INTEGER
Enc13@element = element(6, Val),
encode_unconstrained_number(Enc13@element)
end,
begin
%% attribute transactions(6) with type SEQUENCE OF
Enc15@element = element(7, Val),
if Enc15@element =:= asn1_NOVALUE ->
[];
true ->
enc_Block_transactions(Enc15@element)
end
end,
begin
%% attribute nonce(7) with type INTEGER
Enc17@element = element(8, Val),
encode_unconstrained_number(Enc17@element)
end|begin
%% attribute difficulty(8) with type INTEGER
Enc19@element = element(9, Val),
encode_unconstrained_number(Enc19@element)
end].
enc_Block_transactions(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 12 =:= 0 ->
[<<Enc1@len@sub:12>>|[enc_Transaction(Comp) || Comp <- Val]]
end.



dec_Block(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute version(1) with type INTEGER
{Term1,Bytes3} = begin
{V3@V0,V3@Buf1} = case Bytes2 of
<<0:1,V3@V3:7,V3@Buf4/bitstring>> when V3@V3 =/= 0 ->
{V3@V3,V3@Buf4};
<<1:1,0:1,V3@V4:14,V3@Buf5/bitstring>> when V3@V4 =/= 0 ->
{V3@V4,V3@Buf5}
end,
<<V3@V6:V3@V0/signed-unit:8,V3@Buf7/bitstring>> = V3@Buf1,
{V3@V6,V3@Buf7}
end,

%% attribute index(2) with type INTEGER
{Term2,Bytes4} = begin
{V4@V0,V4@Buf1} = case Bytes3 of
<<0:1,V4@V3:7,V4@Buf4/bitstring>> when V4@V3 =/= 0 ->
{V4@V3,V4@Buf4};
<<1:1,0:1,V4@V4:14,V4@Buf5/bitstring>> when V4@V4 =/= 0 ->
{V4@V4,V4@Buf5}
end,
<<V4@V6:V4@V0/signed-unit:8,V4@Buf7/bitstring>> = V4@Buf1,
{V4@V6,V4@Buf7}
end,

%% attribute hash(3) with type OCTET STRING
{Term3,Bytes5} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V5@V0:64/binary-unit:8,V5@Buf1/bitstring>> = Bytes4,
V5@Conv2 = binary:copy(V5@V0),
{V5@Conv2,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute prev-hash(4) with type OCTET STRING
{Term4,Bytes6} = begin
<<V6@V0:64/binary-unit:8,V6@Buf1/bitstring>> = Bytes5,
V6@Conv2 = binary:copy(V6@V0),
{V6@Conv2,V6@Buf1}
end,

%% attribute timestamp(5) with type INTEGER
{Term5,Bytes7} = begin
{V7@V0,V7@Buf1} = case Bytes6 of
<<0:1,V7@V3:7,V7@Buf4/bitstring>> when V7@V3 =/= 0 ->
{V7@V3,V7@Buf4};
<<1:1,0:1,V7@V4:14,V7@Buf5/bitstring>> when V7@V4 =/= 0 ->
{V7@V4,V7@Buf5}
end,
<<V7@V6:V7@V0/signed-unit:8,V7@Buf7/bitstring>> = V7@Buf1,
{V7@V6,V7@Buf7}
end,

%% attribute transactions(6) with type SEQUENCE OF
{Term6,Bytes8} = case Opt band 1 of
1 ->
dec_Block_transactions(Bytes7);
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute nonce(7) with type INTEGER
{Term7,Bytes9} = begin
{V8@V0,V8@Buf1} = case Bytes8 of
<<0:1,V8@V3:7,V8@Buf4/bitstring>> when V8@V3 =/= 0 ->
{V8@V3,V8@Buf4};
<<1:1,0:1,V8@V4:14,V8@Buf5/bitstring>> when V8@V4 =/= 0 ->
{V8@V4,V8@Buf5}
end,
<<V8@V6:V8@V0/signed-unit:8,V8@Buf7/bitstring>> = V8@Buf1,
{V8@V6,V8@Buf7}
end,

%% attribute difficulty(8) with type INTEGER
{Term8,Bytes10} = begin
{V9@V0,V9@Buf1} = case Bytes9 of
<<0:1,V9@V3:7,V9@Buf4/bitstring>> when V9@V3 =/= 0 ->
{V9@V3,V9@Buf4};
<<1:1,0:1,V9@V4:14,V9@Buf5/bitstring>> when V9@V4 =/= 0 ->
{V9@V4,V9@Buf5}
end,
<<V9@V6:V9@V0/signed-unit:8,V9@Buf7/bitstring>> = V9@Buf1,
{V9@V6,V9@Buf7}
end,

%% Extensions
{Extensions,Bytes11} = case Ext of
0 -> {<<>>,Bytes10};
1 ->
{V10@V0,V10@Buf1} = case Bytes10 of
<<0:1,V10@V3:6,V10@Buf4/bitstring>> ->
V10@Add5 = V10@V3 + 1,
{V10@Add5,V10@Buf4};
<<1:1,V10@Buf2/bitstring>> ->
{V10@V3,V10@Buf4} = case V10@Buf2 of
<<0:1,V10@V6:7,V10@Buf7/bitstring>> when V10@V6 =/= 0 ->
{V10@V6,V10@Buf7};
<<1:1,0:1,V10@V7:14,V10@Buf8/bitstring>> when V10@V7 =/= 0 ->
{V10@V7,V10@Buf8}
end,
{V10@V3,V10@Buf4}
end,
<<V10@V9:V10@V0/bitstring-unit:1,V10@Buf10/bitstring>> = V10@Buf1,
{V10@V9,V10@Buf10}
end,
Bytes12= skipextensions(Bytes11, 1, Extensions),
Res1 = {'Block',Term1,Term2,Term3,Term4,Term5,Term6,Term7,Term8},
{Res1,Bytes12}.


dec_Block_transactions(Bytes) ->
%% Length with constraint {1,4096}
<<V1@V0:12,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components2(V1@Add2, V1@Buf1, []).

enc_Transaction(Val) ->
[begin
%% attribute hash(1) with type OCTET STRING
Enc2@element = element(2, Val),
Enc3@len = byte_size(Enc2@element),
if Enc3@len =:= 64 ->
[<<0:1>>|Enc2@element]
end
end,
begin
%% attribute in(2) with type SEQUENCE OF
Enc4@element = element(3, Val),
enc_Transaction_in(Enc4@element)
end|begin
%% attribute out(3) with type SEQUENCE OF
Enc5@element = element(4, Val),
enc_Transaction_out(Enc5@element)
end].
enc_Transaction_in(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 7 =:= 0 ->
[<<Enc1@len@sub:7>>|[enc_TransactionIn(Comp) || Comp <- Val]]
end.

enc_Transaction_out(Val) ->
Enc1@len = length(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 7 =:= 0 ->
[<<Enc1@len@sub:7>>|[enc_TransactionOut(Comp) || Comp <- Val]]
end.



dec_Transaction(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute hash(1) with type OCTET STRING
{Term1,Bytes2} = begin
<<V2@V0:64/binary-unit:8,V2@Buf1/bitstring>> = Bytes1,
V2@Conv2 = binary:copy(V2@V0),
{V2@Conv2,V2@Buf1}
end,

%% attribute in(2) with type SEQUENCE OF
{Term2,Bytes3} = dec_Transaction_in(Bytes2),

%% attribute out(3) with type SEQUENCE OF
{Term3,Bytes4} = dec_Transaction_out(Bytes3),

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V3@V0,V3@Buf1} = case Bytes4 of
<<0:1,V3@V3:6,V3@Buf4/bitstring>> ->
V3@Add5 = V3@V3 + 1,
{V3@Add5,V3@Buf4};
<<1:1,V3@Buf2/bitstring>> ->
{V3@V3,V3@Buf4} = case V3@Buf2 of
<<0:1,V3@V6:7,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7};
<<1:1,0:1,V3@V7:14,V3@Buf8/bitstring>> when V3@V7 =/= 0 ->
{V3@V7,V3@Buf8}
end,
{V3@V3,V3@Buf4}
end,
<<V3@V9:V3@V0/bitstring-unit:1,V3@Buf10/bitstring>> = V3@Buf1,
{V3@V9,V3@Buf10}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
Res1 = {'Transaction',Term1,Term2,Term3},
{Res1,Bytes6}.


dec_Transaction_in(Bytes) ->
%% Length with constraint {1,128}
<<V1@V0:7,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components3(V1@Add2, V1@Buf1, []).


dec_Transaction_out(Bytes) ->
%% Length with constraint {1,128}
<<V1@V0:7,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
dec_components4(V1@Add2, V1@Buf1, []).

enc_TransactionIn(Val) ->
[begin
Enc1@element = element(2, Val),
Enc2@element = element(4, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
%% attribute out-hash(1) with type OCTET STRING
Enc4@element = element(2, Val),
if Enc4@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc5@len = byte_size(Enc4@element),
if Enc5@len < 128 ->
[Enc5@len|Enc4@element];
Enc5@len < 16384 ->
[<<2:2,Enc5@len:14>>|Enc4@element];
true ->
encode_fragmented(Enc4@element, 8)
end
end
end
end,
begin
%% attribute out-index(2) with type INTEGER
Enc7@element = element(3, Val),
encode_unconstrained_number(Enc7@element)
end|begin
%% attribute signature(3) with type OCTET STRING
Enc9@element = element(4, Val),
if Enc9@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc10@len = byte_size(Enc9@element),
if Enc10@len < 128 ->
[Enc10@len|Enc9@element];
Enc10@len < 16384 ->
[<<2:2,Enc10@len:14>>|Enc9@element];
true ->
encode_fragmented(Enc9@element, 8)
end
end
end
end].


dec_TransactionIn(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute out-hash(1) with type OCTET STRING
{Term1,Bytes3} = case (Opt bsr 1) band 1 of
1 ->
begin
{V3@V0,V3@Buf1} = case Bytes2 of
<<0:1,V3@V3:7,V3@V5:V3@V3/binary-unit:8,V3@Buf6/bitstring>> ->
{V3@V5,V3@Buf6};
<<1:1,0:1,V3@V4:14,V3@V6:V3@V4/binary-unit:8,V3@Buf7/bitstring>> ->
{V3@V6,V3@Buf7};
<<1:1,1:1,V3@V4:6,V3@Buf5/bitstring>> ->
{V3@V6,V3@Buf7}  = decode_fragmented(V3@V4, V3@Buf5, 8),
{V3@V6,V3@Buf7}
end,
V3@Conv8 = binary:copy(V3@V0),
{V3@Conv8,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute out-index(2) with type INTEGER
{Term2,Bytes4} = begin
{V4@V0,V4@Buf1} = case Bytes3 of
<<0:1,V4@V3:7,V4@Buf4/bitstring>> when V4@V3 =/= 0 ->
{V4@V3,V4@Buf4};
<<1:1,0:1,V4@V4:14,V4@Buf5/bitstring>> when V4@V4 =/= 0 ->
{V4@V4,V4@Buf5}
end,
<<V4@V6:V4@V0/signed-unit:8,V4@Buf7/bitstring>> = V4@Buf1,
{V4@V6,V4@Buf7}
end,

%% attribute signature(3) with type OCTET STRING
{Term3,Bytes5} = case Opt band 1 of
1 ->
begin
{V5@V0,V5@Buf1} = case Bytes4 of
<<0:1,V5@V3:7,V5@V5:V5@V3/binary-unit:8,V5@Buf6/bitstring>> ->
{V5@V5,V5@Buf6};
<<1:1,0:1,V5@V4:14,V5@V6:V5@V4/binary-unit:8,V5@Buf7/bitstring>> ->
{V5@V6,V5@Buf7};
<<1:1,1:1,V5@V4:6,V5@Buf5/bitstring>> ->
{V5@V6,V5@Buf7}  = decode_fragmented(V5@V4, V5@Buf5, 8),
{V5@V6,V5@Buf7}
end,
V5@Conv8 = binary:copy(V5@V0),
{V5@Conv8,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% Extensions
{Extensions,Bytes6} = case Ext of
0 -> {<<>>,Bytes5};
1 ->
{V6@V0,V6@Buf1} = case Bytes5 of
<<0:1,V6@V3:6,V6@Buf4/bitstring>> ->
V6@Add5 = V6@V3 + 1,
{V6@Add5,V6@Buf4};
<<1:1,V6@Buf2/bitstring>> ->
{V6@V3,V6@Buf4} = case V6@Buf2 of
<<0:1,V6@V6:7,V6@Buf7/bitstring>> when V6@V6 =/= 0 ->
{V6@V6,V6@Buf7};
<<1:1,0:1,V6@V7:14,V6@Buf8/bitstring>> when V6@V7 =/= 0 ->
{V6@V7,V6@Buf8}
end,
{V6@V3,V6@Buf4}
end,
<<V6@V9:V6@V0/bitstring-unit:1,V6@Buf10/bitstring>> = V6@Buf1,
{V6@V9,V6@Buf10}
end,
Bytes7= skipextensions(Bytes6, 1, Extensions),
Res1 = {'TransactionIn',Term1,Term2,Term3},
{Res1,Bytes7}.

enc_TransactionOut(Val) ->
[begin
%% attribute address(1) with type OCTET STRING
Enc2@element = element(2, Val),
Enc3@len = byte_size(Enc2@element),
if Enc3@len =:= 32 ->
[<<0:1>>|Enc2@element]
end
end|begin
%% attribute amount(2) with type INTEGER
Enc4@element = element(3, Val),
encode_unconstrained_number(Enc4@element)
end].


dec_TransactionOut(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute address(1) with type OCTET STRING
{Term1,Bytes2} = begin
<<V2@V0:32/binary-unit:8,V2@Buf1/bitstring>> = Bytes1,
V2@Conv2 = binary:copy(V2@V0),
{V2@Conv2,V2@Buf1}
end,

%% attribute amount(2) with type INTEGER
{Term2,Bytes3} = begin
{V3@V0,V3@Buf1} = case Bytes2 of
<<0:1,V3@V3:7,V3@Buf4/bitstring>> when V3@V3 =/= 0 ->
{V3@V3,V3@Buf4};
<<1:1,0:1,V3@V4:14,V3@Buf5/bitstring>> when V3@V4 =/= 0 ->
{V3@V4,V3@Buf5}
end,
<<V3@V6:V3@V0/signed-unit:8,V3@Buf7/bitstring>> = V3@Buf1,
{V3@V6,V3@Buf7}
end,

%% Extensions
{Extensions,Bytes4} = case Ext of
0 -> {<<>>,Bytes3};
1 ->
{V4@V0,V4@Buf1} = case Bytes3 of
<<0:1,V4@V3:6,V4@Buf4/bitstring>> ->
V4@Add5 = V4@V3 + 1,
{V4@Add5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<0:1,V4@V6:7,V4@Buf7/bitstring>> when V4@V6 =/= 0 ->
{V4@V6,V4@Buf7};
<<1:1,0:1,V4@V7:14,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
{V4@V7,V4@Buf8}
end,
{V4@V3,V4@Buf4}
end,
<<V4@V9:V4@V0/bitstring-unit:1,V4@Buf10/bitstring>> = V4@Buf1,
{V4@V9,V4@Buf10}
end,
Bytes5= skipextensions(Bytes4, 1, Extensions),
Res1 = {'TransactionOut',Term1,Term2},
{Res1,Bytes5}.



%%================================
%%  Hash
%%================================
typeinfo_Hash() ->
octet_string.



%%================================
%%  PublicKey
%%================================
typeinfo_PublicKey() ->
octet_string.



%%================================
%%  BranchSet
%%================================
typeinfo_BranchSet() ->
{sof,{sequence,'BranchSet_SEQOF',2,[{<<115,108,111,116>>,'INTEGER',mandatory},{<<98,114,97,110,99,104>>,{typeinfo,{'CoinProto',typeinfo_Branch}},mandatory}]}}.



%%================================
%%  Branch
%%================================
typeinfo_Branch() ->
{sequence,'Branch',6,[{<<108,97,116,101,115,116,45,104,97,115,104>>,octet_string,mandatory},{<<99,117,114,114,101,110,116,45,100,105,102,102,105,99,117,108,116,121>>,'INTEGER',mandatory},{<<99,117,109,117,108,97,116,105,118,101,45,100,105,102,102,105,99,117,108,116,121>>,'INTEGER',mandatory},{<<108,101,110,103,116,104>>,'INTEGER',mandatory},{<<99,111,105,110,98,97,115,101>>,'INTEGER',mandatory},{<<115,117,112,112,108,121>>,'INTEGER',mandatory}]}.



%%================================
%%  Block
%%================================
typeinfo_Block() ->
{sequence,'Block',8,[{<<118,101,114,115,105,111,110>>,'INTEGER',mandatory},{<<105,110,100,101,120>>,'INTEGER',mandatory},{<<104,97,115,104>>,octet_string,'OPTIONAL'},{<<112,114,101,118,45,104,97,115,104>>,octet_string,mandatory},{<<116,105,109,101,115,116,97,109,112>>,'INTEGER',mandatory},{<<116,114,97,110,115,97,99,116,105,111,110,115>>,{sof,{typeinfo,{'CoinProto',typeinfo_Transaction}}},'OPTIONAL'},{<<110,111,110,99,101>>,'INTEGER',mandatory},{<<100,105,102,102,105,99,117,108,116,121>>,'INTEGER',mandatory}]}.



%%================================
%%  Transaction
%%================================
typeinfo_Transaction() ->
{sequence,'Transaction',3,[{<<104,97,115,104>>,octet_string,mandatory},{<<105,110>>,{sof,{typeinfo,{'CoinProto',typeinfo_TransactionIn}}},mandatory},{<<111,117,116>>,{sof,{typeinfo,{'CoinProto',typeinfo_TransactionOut}}},mandatory}]}.



%%================================
%%  TransactionIn
%%================================
typeinfo_TransactionIn() ->
{sequence,'TransactionIn',3,[{<<111,117,116,45,104,97,115,104>>,octet_string,'OPTIONAL'},{<<111,117,116,45,105,110,100,101,120>>,'INTEGER',mandatory},{<<115,105,103,110,97,116,117,114,101>>,octet_string,'OPTIONAL'}]}.



%%================================
%%  TransactionOut
%%================================
typeinfo_TransactionOut() ->
{sequence,'TransactionOut',2,[{<<97,100,100,114,101,115,115>>,octet_string,mandatory},{<<97,109,111,117,110,116>>,'INTEGER',mandatory}]}.


%%%
%%% Run-time functions.
%%%

'dialyzer-suppressions'(Arg) ->
    complete(element(1, Arg)),
    ok.

dec_components1(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components1(Num, Bytes, Acc) ->
{Term,Remain} = dec_BranchSet_SEQOF(Bytes),
dec_components1(Num-1, Remain, [Term|Acc]).

dec_components2(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components2(Num, Bytes, Acc) ->
{Term,Remain} = dec_Transaction(Bytes),
dec_components2(Num-1, Remain, [Term|Acc]).

dec_components3(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components3(Num, Bytes, Acc) ->
{Term,Remain} = dec_TransactionIn(Bytes),
dec_components3(Num-1, Remain, [Term|Acc]).

dec_components4(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components4(Num, Bytes, Acc) ->
{Term,Remain} = dec_TransactionOut(Bytes),
dec_components4(Num-1, Remain, [Term|Acc]).

bitstring2json(BitStr) when is_binary(BitStr) ->
    octetstring2json(binary_to_list(BitStr));
bitstring2json(BitStr) ->
    Pad = 8 - bit_size(BitStr) rem 8,
    NewStr = <<BitStr/bitstring,0:Pad>>,
    octetstring2json(binary_to_list(NewStr)).

complete(InList) when is_list(InList) ->
    case list_to_bitstring(InList) of
        <<>> ->
            <<0>>;
        Res ->
            Sz = bit_size(Res),
            case Sz band 7 of
                0 ->
                    Res;
                Bits ->
                    <<Res:Sz/bitstring,0:(8 - Bits)>>
            end
    end;
complete(Bin) when is_binary(Bin) ->
    case Bin of
        <<>> ->
            <<0>>;
        _ ->
            Bin
    end;
complete(InList) when is_bitstring(InList) ->
    Sz = bit_size(InList),
    PadLen = 8 - Sz band 7,
    <<InList:Sz/bitstring,0:PadLen>>.

decode_fragmented(SegSz0, Buf0, Unit) ->
    SegSz = SegSz0 * Unit * 16384,
    <<Res:SegSz/bitstring,Buf/bitstring>> = Buf0,
    decode_fragmented_1(Buf, Unit, Res).

decode_fragmented_1(<<0:1,N:7,Buf0/bitstring>>, Unit, Res) ->
    Sz = N * Unit,
    <<S:Sz/bitstring,Buf/bitstring>> = Buf0,
    {<<Res/bitstring,S/bitstring>>, Buf};
decode_fragmented_1(<<1:1,0:1,N:14,Buf0/bitstring>>, Unit, Res) ->
    Sz = N * Unit,
    <<S:Sz/bitstring,Buf/bitstring>> = Buf0,
    {<<Res/bitstring,S/bitstring>>, Buf};
decode_fragmented_1(<<1:1,1:1,SegSz0:6,Buf0/bitstring>>, Unit, Res0) ->
    SegSz = SegSz0 * Unit * 16384,
    <<Frag:SegSz/bitstring,Buf/bitstring>> = Buf0,
    Res = <<Res0/bitstring,Frag/bitstring>>,
    decode_fragmented_1(Buf, Unit, Res).

decode_jer(Module, InfoFunc, Val) ->
    Info = Module:InfoFunc(),
    decode_jer(Info, Val).

decode_jer({'ENUMERATED', _EnumList}, Val) when is_binary(Val) ->
    binary_to_existing_atom(Val, utf8);
decode_jer({'ENUMERATED', _EnumList}, Val) when is_boolean(Val) ->
    Val;
decode_jer({'ENUMERATED', _EnumList}, null) ->
    null;
decode_jer({Type = {'ENUMERATED', _EnumList}, _Constr}, Val) ->
    decode_jer(Type, Val);
decode_jer({'ENUMERATED_EXT', EnumList}, Val) ->
    decode_jer({'ENUMERATED', EnumList}, Val);
decode_jer({Type = {'ENUMERATED_EXT', _EnumList}, _Constr}, Val) ->
    decode_jer(Type, Val);
decode_jer({typeinfo, {Module, Func}}, Val) ->
    TypeInfo = Module:Func(),
    decode_jer(TypeInfo, Val);
decode_jer({sequence, Sname, _Arity, CompInfos}, Value)
    when is_map(Value) ->
    DecodedComps = decode_jer_component(CompInfos, Value, []),
    list_to_tuple([Sname | DecodedComps]);
decode_jer(string, Str) when is_binary(Str) ->
    binary_to_list(Str);
decode_jer({string, _Prop}, Str) when is_binary(Str) ->
    binary_to_list(Str);
decode_jer('INTEGER', Int) when is_integer(Int) ->
    Int;
decode_jer({'INTEGER', {Min, Max}}, Int)
    when is_integer(Int), Max >= Int, Int >= Min ->
    Int;
decode_jer({Type = {'INTEGER_NNL', _NNList}, _}, Int) ->
    decode_jer(Type, Int);
decode_jer({'INTEGER_NNL', NNList}, Int) ->
    case lists:keyfind(Int, 2, NNList) of
        {NewName, _} ->
            NewName;
        _ ->
            Int
    end;
decode_jer('BOOLEAN', Bool) when is_boolean(Bool) ->
    Bool;
decode_jer({'BOOLEAN', _Prop}, Bool) when is_boolean(Bool) ->
    Bool;
decode_jer('NULL', null) ->
    'NULL';
decode_jer(legacy_octet_string, Str) when is_binary(Str) ->
    json2octetstring2string(binary_to_list(Str));
decode_jer(octet_string, Str) when is_binary(Str) ->
    json2octetstring2binary(binary_to_list(Str));
decode_jer({sof, Type}, Vals) when is_list(Vals) ->
    [ 
     decode_jer(Type, Val) ||
         Val <- Vals
    ];
decode_jer({choice, ChoiceTypes}, ChoiceVal) ->
    [{Alt, Val}] = maps:to_list(ChoiceVal),
    case ChoiceTypes of
        #{Alt := Type} ->
            Type = maps:get(Alt, ChoiceTypes),
            {binary_to_atom(Alt, utf8), decode_jer(Type, Val)};
        _ ->
            exit({error,
                  {asn1, {invalid_choice, Alt, maps:keys(ChoiceTypes)}}})
    end;
decode_jer(bit_string, #{<<"value">> := Str, <<"length">> := Length}) ->
    json2bitstring(binary_to_list(Str), Length);
decode_jer({bit_string, FixedLength}, Str) when is_binary(Str) ->
    json2bitstring(binary_to_list(Str), FixedLength);
decode_jer({bit_string_nnl, NNL},
           #{<<"value">> := Str, <<"length">> := Length}) ->
    BitStr = json2bitstring(binary_to_list(Str), Length),
    jer_bitstr2names(BitStr, NNL);
decode_jer({{bit_string_nnl, NNL}, FixedLength}, Str)
    when is_binary(Str) ->
    BitStr = json2bitstring(binary_to_list(Str), FixedLength),
    jer_bitstr2names(BitStr, NNL);
decode_jer({compact_bit_string_nnl, NNL}, Value) ->
    decode_jer({bit_string_nnl, NNL}, Value);
decode_jer({{compact_bit_string_nnl, NNL}, FixedLength}, Value) ->
    decode_jer({{bit_string_nnl, NNL}, FixedLength}, Value);
decode_jer(compact_bit_string,
           #{<<"value">> := Str, <<"length">> := Length}) ->
    BitStr = json2bitstring(binary_to_list(Str), Length),
    jer_bitstr2compact(BitStr);
decode_jer({compact_bit_string, FixedLength}, Str) ->
    BitStr = json2bitstring(binary_to_list(Str), FixedLength),
    Unused = (8 - FixedLength rem 8) band 7,
    {Unused, <<BitStr/bitstring,0:Unused>>};
decode_jer('OBJECT IDENTIFIER', OidBin) when is_binary(OidBin) ->
    json2oid(OidBin);
decode_jer('RELATIVE-OID', OidBin) when is_binary(OidBin) ->
    json2oid(OidBin);
decode_jer({'ObjClassFieldType', _, _}, Bin) when is_binary(Bin) ->
    Bin;
decode_jer('ASN1_OPEN_TYPE', Bin) when is_binary(Bin) ->
    Bin;
decode_jer(Type, Val) ->
    exit({error, {asn1, {{decode, Type}, Val}}}).

decode_jer_component([{Name, Type, _OptOrDefault} | CompInfos],
                     VMap, Acc)
    when is_map_key(Name, VMap) ->
    Value = maps:get(Name, VMap),
    Dec = decode_jer(Type, Value),
    decode_jer_component(CompInfos, VMap, [Dec | Acc]);
decode_jer_component([{_Name, _Type, 'OPTIONAL'} | CompInfos],
                     VMap, Acc) ->
    decode_jer_component(CompInfos, VMap, [asn1_NOVALUE | Acc]);
decode_jer_component([{_Name, _Type, {'DEFAULT', Dvalue}} | CompInfos],
                     VMap, Acc) ->
    decode_jer_component(CompInfos, VMap, [Dvalue | Acc]);
decode_jer_component([{Name, _Type, _OptOrDefault} | _CompInfos],
                     VMap, _Acc) ->
    exit({error,
          {asn1, {{decode, {mandatory_component_missing, Name}}, VMap}}});
decode_jer_component([], _, Acc) ->
    lists:reverse(Acc).

decode_length(<<0:1,Oct:7,Rest/bitstring>>) ->
    {Oct, Rest};
decode_length(<<2:2,Val:14,Rest/bitstring>>) ->
    {Val, Rest};
decode_length(<<3:2,_:14,_Rest/bitstring>>) ->
    exit({error, {asn1, {decode_length, {nyi, above_16k}}}}).

encode_bitstring([B8, B7, B6, B5, B4, B3, B2, B1 | Rest]) ->
    Val =
        B8 bsl 7 bor (B7 bsl 6) bor (B6 bsl 5) bor (B5 bsl 4)
        bor
        (B4 bsl 3)
        bor
        (B3 bsl 2)
        bor
        (B2 bsl 1)
        bor
        B1,
    encode_bitstring(Rest, <<Val>>);
encode_bitstring(Val) ->
    unused_bitlist(Val, <<>>).

encode_bitstring([B8, B7, B6, B5, B4, B3, B2, B1 | Rest], Ack) ->
    Val =
        B8 bsl 7 bor (B7 bsl 6) bor (B6 bsl 5) bor (B5 bsl 4)
        bor
        (B4 bsl 3)
        bor
        (B3 bsl 2)
        bor
        (B2 bsl 1)
        bor
        B1,
    encode_bitstring(Rest, [Ack, Val]);
encode_bitstring([], Ack) ->
    Ack;
encode_bitstring(Rest, Ack) ->
    unused_bitlist(Rest, Ack).

encode_fragmented(Bin, Unit) ->
    encode_fragmented_1(Bin, Unit, 4).

encode_fragmented_1(Bin, Unit, N) ->
    SegSz = Unit * N * 16384,
    case Bin of
        <<B:SegSz/bitstring,T/bitstring>> ->
            [<<3:2,N:6>>, B | encode_fragmented_1(T, Unit, N)];
        _ when N > 1 ->
            encode_fragmented_1(Bin, Unit, N - 1);
        _ ->
            case bit_size(Bin) div Unit of
                Len when Len < 128 ->
                    [Len, Bin];
                Len when Len < 16384 ->
                    [<<2:2,Len:14>>, Bin]
            end
    end.

encode_jer(Module, InfoFunc, Val) ->
    Info = Module:InfoFunc(),
    encode_jer(Info, Val).

encode_jer({sequence_tab, Simple, Sname, Arity, CompInfos}, Value)
    when tuple_size(Value) == Arity + 1 ->
    [Sname | Clist] = tuple_to_list(Value),
    encode_jer_component_tab(CompInfos, Clist, Simple, #{});
encode_jer({sequence, Sname, Arity, CompInfos}, Value)
    when tuple_size(Value) == Arity + 1 ->
    [Sname | Clist] = tuple_to_list(Value),
    encode_jer_component(CompInfos, Clist, []);
encode_jer(string, Str) when is_list(Str) ->
    list_to_binary(Str);
encode_jer({string, _Prop}, Str) when is_list(Str) ->
    list_to_binary(Str);
encode_jer(string, Str) when is_binary(Str) ->
    Str;
encode_jer({string, _Prop}, Str) when is_binary(Str) ->
    Str;
encode_jer('INTEGER', Int) when is_integer(Int) ->
    Int;
encode_jer({'INTEGER', {Min, Max}}, Int)
    when is_integer(Int), Max >= Int, Int >= Min ->
    Int;
encode_jer({'INTEGER_NNL', _NNL}, Int) when is_integer(Int) ->
    Int;
encode_jer(Type = {'INTEGER_NNL', NNList}, Int) when is_atom(Int) ->
    case lists:keyfind(Int, 1, NNList) of
        {_, NewVal} ->
            NewVal;
        _ ->
            exit({error, {asn1, {Type, Int}}})
    end;
encode_jer({Type = {'INTEGER_NNL', _NNList}, _Constraint}, Int)
    when is_atom(Int) ->
    encode_jer(Type, Int);
encode_jer({{'INTEGER_NNL', _NNList}, Constraint}, Int)
    when is_integer(Int) ->
    encode_jer({'INTEGER', Constraint}, Int);
encode_jer('BOOLEAN', Bool) when is_boolean(Bool) ->
    Bool;
encode_jer({'BOOLEAN', _Prop}, Bool) when is_boolean(Bool) ->
    Bool;
encode_jer('NULL', _) ->
    null;
encode_jer(legacy_octet_string, Value) when is_list(Value) ->
    bitstring2json(list_to_binary(Value));
encode_jer({legacy_octet_string, _Prop}, Value) when is_list(Value) ->
    bitstring2json(list_to_binary(Value));
encode_jer(octet_string, Value) when is_binary(Value) ->
    encode_jer({octet_string, []}, Value);
encode_jer({octet_string, _Prop}, Value) when is_binary(Value) ->
    bitstring2json(Value);
encode_jer({'ENUMERATED', EnumMap}, Val) when is_map_key(Val, EnumMap) ->
    Val;
encode_jer({Type = {'ENUMERATED', _EnumList}, _Constr}, Val) ->
    encode_jer(Type, Val);
encode_jer({'ENUMERATED_EXT', _EnumMap}, Val) when is_atom(Val) ->
    Val;
encode_jer({Type = {'ENUMERATED_EXT', _EnumList}, _Constr}, Val) ->
    encode_jer(Type, Val);
encode_jer({typeinfo, {Module, Func}}, Val) ->
    TypeInfo = Module:Func(),
    encode_jer(TypeInfo, Val);
encode_jer({sof, Type}, Vals) when is_list(Vals) ->
    [ 
     encode_jer(Type, Val) ||
         Val <- Vals
    ];
encode_jer({choice, Choices}, {Alt, Value}) ->
    case is_map_key(AltBin = atom_to_binary(Alt, utf8), Choices) of
        true ->
            EncodedVal = encode_jer(maps:get(AltBin, Choices), Value),
            #{AltBin => EncodedVal};
        false ->
            exit({error, {asn1, {invalid_choice, Alt, Choices}}})
    end;
encode_jer(bit_string, Value) ->
    Str = bitstring2json(Value),
    #{value => Str, length => bit_size(Value)};
encode_jer({bit_string, FixedLength}, Value)
    when is_bitstring(Value), is_integer(FixedLength) ->
    Value2 = jer_padbitstr(Value, FixedLength),
    bitstring2json(Value2);
encode_jer(compact_bit_string, Compact) ->
    BitStr = jer_compact2bitstr(Compact),
    encode_jer(bit_string, BitStr);
encode_jer({compact_bit_string, FixedLength},
           Compact = {_Unused, Binary})
    when is_binary(Binary) ->
    BitStr = jer_compact2bitstr(Compact),
    encode_jer({bit_string, FixedLength}, BitStr);
encode_jer({bit_string_nnl, NNL}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer(bit_string, Value1);
encode_jer({{bit_string_nnl, NNL}, FixedLength}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer({bit_string, FixedLength}, Value1);
encode_jer({compact_bit_string_nnl, NNL}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer(bit_string, Value1);
encode_jer({{compact_bit_string_nnl, NNL}, FixedLength}, Value) ->
    Value1 = jer_bit_str2bitstr(Value, NNL),
    encode_jer({bit_string, FixedLength}, Value1);
encode_jer('OBJECT IDENTIFIER', Oid) when is_tuple(Oid) ->
    oid2json(Oid);
encode_jer('RELATIVE-OID', Oid) when is_tuple(Oid) ->
    oid2json(Oid);
encode_jer({'ObjClassFieldType', _, _}, Val) when is_binary(Val) ->
    Val;
encode_jer('ASN1_OPEN_TYPE', Val) when is_binary(Val) ->
    Val;
encode_jer(Type, Val) ->
    exit({error, {asn1, {{encode, Type}, Val}}}).

encode_jer_component([{_Name, _Type, 'OPTIONAL'} | CompInfos],
                     [asn1_NOVALUE | Rest],
                     Acc) ->
    encode_jer_component(CompInfos, Rest, Acc);
encode_jer_component([{_Name, _Type, {'DEFAULT', _}} | CompInfos],
                     [asn1_DEFAULT | Rest],
                     Acc) ->
    encode_jer_component(CompInfos, Rest, Acc);
encode_jer_component([{Name, Type, _OptOrDefault} | CompInfos],
                     [Value | Rest],
                     Acc) ->
    Enc = encode_jer(Type, Value),
    encode_jer_component(CompInfos, Rest, [{Name, Enc} | Acc]);
encode_jer_component([], _, []) ->
    #{};
encode_jer_component([], _, Acc) ->
    lists:reverse(Acc).

encode_jer_component_tab([{_Name, _Type, 'OPTIONAL'} | CompInfos],
                         [asn1_NOVALUE | Rest],
                         Simple, MapAcc) ->
    encode_jer_component_tab(CompInfos, Rest, Simple, MapAcc);
encode_jer_component_tab([{_Name, _Type, {'DEFAULT', _}} | CompInfos],
                         [asn1_DEFAULT | Rest],
                         Simple, MapAcc) ->
    encode_jer_component_tab(CompInfos, Rest, Simple, MapAcc);
encode_jer_component_tab([{Name, Type, _OptOrDefault} | CompInfos],
                         [Value | Rest],
                         Simple, MapAcc) ->
    Enc = encode_jer(Type, Value),
    encode_jer_component_tab(CompInfos, Rest, Simple,
                             MapAcc#{Name => Enc});
encode_jer_component_tab([], _, _Simple, MapAcc) ->
    MapAcc.

encode_unconstrained_number(Val) when not is_integer(Val) ->
    exit({error, {asn1, {illegal_integer, Val}}});
encode_unconstrained_number(Val) when Val >= 0 ->
    if
        Val < 128 ->
            [1, Val];
        Val < 256 ->
            [<<2,0>>, Val];
        true ->
            case binary:encode_unsigned(Val) of
                <<0:1,_/bitstring>> = Bin ->
                    case byte_size(Bin) of
                        Sz when Sz < 128 ->
                            [Sz, Bin];
                        Sz when Sz < 16384 ->
                            [<<2:2,Sz:14>>, Bin]
                    end;
                <<1:1,_/bitstring>> = Bin ->
                    case byte_size(Bin) + 1 of
                        Sz when Sz < 128 ->
                            [Sz, 0, Bin];
                        Sz when Sz < 16384 ->
                            [<<2:2,Sz:14,0:8>>, Bin]
                    end
            end
    end;
encode_unconstrained_number(Val) ->
    Oct = enint(Val, []),
    Len = length(Oct),
    if
        Len < 128 ->
            [Len | Oct];
        Len < 16384 ->
            [<<2:2,Len:14>> | Oct]
    end.

enint(- 1, [B1 | T]) when B1 > 127 ->
    [B1 | T];
enint(N, Acc) ->
    enint(N bsr 8, [N band 255 | Acc]).

jer_bit_str2bitstr(Compact = {_Unused, _Binary}, _NamedBitList) ->
    jer_compact2bitstr(Compact);
jer_bit_str2bitstr(Int, _NamedBitList) when is_integer(Int) ->
    jer_compact2bitstr(Int);
jer_bit_str2bitstr(BitList = [Bit | _], _NamedBitList)
    when Bit == 1; Bit == 0 ->
    Int =
        list_to_integer([ 
                         case B of
                             0 ->
                                 $0;
                             1 ->
                                 $1
                         end ||
                             B <- BitList
                        ],
                        2),
    Len = length(BitList),
    <<Int:Len>>;
jer_bit_str2bitstr([H | _] = Bits, NamedBitList) when is_atom(H) ->
    jer_do_encode_named_bit_string(Bits, NamedBitList);
jer_bit_str2bitstr([{bit, _} | _] = Bits, NamedBitList) ->
    jer_do_encode_named_bit_string(Bits, NamedBitList);
jer_bit_str2bitstr([], _NamedBitList) ->
    <<>>;
jer_bit_str2bitstr(BitStr, _NamedBitList) when is_bitstring(BitStr) ->
    BitStr.

jer_bitstr2compact(BitStr) ->
    Size = bit_size(BitStr),
    Unused = (8 - Size rem 8) band 7,
    {Unused, <<BitStr/bitstring,0:Unused>>}.

jer_bitstr2names(<<1:1,BitStr/bitstring>>,
                 [{Name, Pos} | Rest],
                 Pos, Acc) ->
    jer_bitstr2names(BitStr, Rest, Pos + 1, [Name | Acc]);
jer_bitstr2names(<<1:1,BitStr/bitstring>>, NNL, Num, Acc) ->
    jer_bitstr2names(BitStr, NNL, Num + 1, [{bit, Num} | Acc]);
jer_bitstr2names(<<0:1,BitStr/bitstring>>, [{_, Num} | Rest], Num, Acc) ->
    jer_bitstr2names(BitStr, Rest, Num + 1, Acc);
jer_bitstr2names(<<0:1,BitStr/bitstring>>, NNL, Num, Acc) ->
    jer_bitstr2names(BitStr, NNL, Num + 1, Acc);
jer_bitstr2names(<<>>, _, _, Acc) ->
    lists:reverse(Acc).

jer_bitstr2names(BitStr, []) ->
    BitStr;
jer_bitstr2names(BitStr, NNL) ->
    SortedList = lists:keysort(2, NNL),
    jer_bitstr2names(BitStr, SortedList, 0, []).

jer_compact2bitstr({Unused, Binary}) ->
    Size = bit_size(Binary) - Unused,
    <<BitStr:Size/bitstring,_/bitstring>> = Binary,
    BitStr;
jer_compact2bitstr(Int) when is_integer(Int) ->
    jer_int2bitstr(Int);
jer_compact2bitstr(BitList = [Bit | _]) when Bit == 1; Bit == 0 ->
    IntStr = jer_skip_trailing_zeroes(BitList, []),
    Int = list_to_integer(IntStr, 2),
    Len = length(IntStr),
    <<Int:Len>>.

jer_do_encode_named_bit_string([FirstVal | RestVal], NamedBitList) ->
    ToSetPos =
        jer_get_all_bitposes([FirstVal | RestVal], NamedBitList, []),
    Size = lists:max(ToSetPos) + 1,
    BitList = jer_make_and_set_list(Size, ToSetPos, 0),
    encode_bitstring(BitList).

jer_get_all_bitposes([{bit, ValPos} | Rest], NamedBitList, Ack) ->
    jer_get_all_bitposes(Rest, NamedBitList, [ValPos | Ack]);
jer_get_all_bitposes([Val | Rest], NamedBitList, Ack) when is_atom(Val) ->
    case lists:keyfind(Val, 1, NamedBitList) of
        {_ValName, ValPos} ->
            jer_get_all_bitposes(Rest, NamedBitList, [ValPos | Ack]);
        _ ->
            exit({error, {asn1, {bitstring_namedbit, Val}}})
    end;
jer_get_all_bitposes([], _NamedBitList, Ack) ->
    lists:sort(Ack).

jer_int2bitstr(0, Acc) ->
    Acc;
jer_int2bitstr(Int, Acc) ->
    Bit = Int band 1,
    jer_int2bitstr(Int bsr 1, <<Acc/bitstring,Bit:1>>).

jer_int2bitstr(Int) when is_integer(Int), Int >= 0 ->
    jer_int2bitstr(Int, <<>>).

jer_make_and_set_list(0, [], _) ->
    [];
jer_make_and_set_list(0, _, _) ->
    exit({error, {asn1, bitstring_sizeconstraint}});
jer_make_and_set_list(Len, [XPos | SetPos], XPos) ->
    [1 | jer_make_and_set_list(Len - 1, SetPos, XPos + 1)];
jer_make_and_set_list(Len, [Pos | SetPos], XPos) ->
    [0 | jer_make_and_set_list(Len - 1, [Pos | SetPos], XPos + 1)];
jer_make_and_set_list(Len, [], XPos) ->
    [0 | jer_make_and_set_list(Len - 1, [], XPos + 1)].

jer_padbitstr(BitStr, FixedLength) when bit_size(BitStr) == FixedLength ->
    BitStr;
jer_padbitstr(BitStr, FixedLength) when bit_size(BitStr) < FixedLength ->
    Len = bit_size(BitStr),
    PadLen = FixedLength - Len,
    <<BitStr/bitstring,0:PadLen>>.

jer_skip_trailing_zeroes([1 | Rest], Acc) ->
    jer_skip_trailing_zeroes(Rest, [$1 | Acc]);
jer_skip_trailing_zeroes([0 | Rest], Acc) ->
    jer_skip_trailing_zeroes(Rest, [$0 | Acc]);
jer_skip_trailing_zeroes([], [$0 | Acc]) ->
    jer_skip_trailing_zeroes([], Acc);
jer_skip_trailing_zeroes([], Acc) ->
    lists:reverse(Acc).

json2bitstring(Value, Length) ->
    json2bitstring(Value, Length, []).

json2bitstring([A1, A2], Length, Acc) ->
    Int = list_to_integer([A1, A2], 16) bsr (8 - Length),
    Bin = list_to_binary(lists:reverse(Acc)),
    <<Bin/binary,Int:Length>>;
json2bitstring([A1, A2 | Rest], Length, Acc) ->
    Int = list_to_integer([A1, A2], 16),
    json2bitstring(Rest, Length - 8, [Int | Acc]);
json2bitstring([], 0, Acc) ->
    Bin = list_to_binary(lists:reverse(Acc)),
    Bin.

json2octetstring([A1, A2 | Rest], Acc) ->
    Int = list_to_integer([A1, A2], 16),
    json2octetstring(Rest, [Int | Acc]);
json2octetstring([], Acc) ->
    lists:reverse(Acc).

json2octetstring2binary(Value) ->
    list_to_binary(json2octetstring(Value, [])).

json2octetstring2string(Value) ->
    json2octetstring(Value, []).

json2oid(OidStr) when is_binary(OidStr) ->
    OidList = binary:split(OidStr, [<<".">>], [global]),
    OidNumList =
        [ 
         binary_to_integer(Num) ||
             Num <- OidList
        ],
    list_to_tuple(OidNumList).

octetstring2json(List) when is_list(List) ->
    list_to_binary([ 
                    begin
                        Num = integer_to_list(X, 16),
                        if
                            length(Num) == 1 ->
                                "0" ++ Num;
                            true ->
                                Num
                        end
                    end ||
                        X <- List
                   ]).

oid2json(Oid) when is_tuple(Oid) ->
    OidList = tuple_to_list(Oid),
    OidNumberStr =
        [ 
         integer_to_list(V) ||
             V <- OidList
        ],
    oid2json(OidNumberStr, []).

oid2json([Num | T], []) ->
    oid2json(T, [Num]);
oid2json([Num | T], Acc) ->
    oid2json(T, [Num, $. | Acc]);
oid2json([], Acc) ->
    list_to_binary(lists:reverse(Acc)).

skipextensions(Bytes0, Nr, ExtensionBitstr)
    when is_bitstring(ExtensionBitstr) ->
    Prev = Nr - 1,
    case ExtensionBitstr of
        <<_:Prev,1:1,_/bitstring>> ->
            {Len, Bytes1} = decode_length(Bytes0),
            <<_:Len/binary,Bytes2/bitstring>> = Bytes1,
            skipextensions(Bytes2, Nr + 1, ExtensionBitstr);
        <<_:Prev,0:1,_/bitstring>> ->
            skipextensions(Bytes0, Nr + 1, ExtensionBitstr);
        _ ->
            Bytes0
    end.

unused_bitlist([], Ack) ->
    Ack;
unused_bitlist([Bit | Rest], Ack) ->
    unused_bitlist(Rest, <<Ack/bitstring,Bit:1>>).
